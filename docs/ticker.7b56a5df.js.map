{"mappings":"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","sources":["<anon>","packages/metronome/src/utils/ticker.ts","node_modules/comlink/dist/esm/comlink.mjs","node_modules/comlink/src/comlink.ts","node_modules/@swc/helpers/esm/_construct.js","node_modules/@swc/helpers/esm/_is_native_reflect_construct.js","node_modules/@swc/helpers/esm/_set_prototype_of.js","node_modules/@swc/helpers/esm/_define_property.js","node_modules/@swc/helpers/esm/_sliced_to_array.js","node_modules/@swc/helpers/esm/_array_with_holes.js","node_modules/@swc/helpers/esm/_iterable_to_array_limit.js","node_modules/@swc/helpers/esm/_non_iterable_rest.js","node_modules/@swc/helpers/esm/_unsupported_iterable_to_array.js","node_modules/@swc/helpers/esm/_array_like_to_array.js","node_modules/@swc/helpers/esm/_to_consumable_array.js","node_modules/@swc/helpers/esm/_array_without_holes.js","node_modules/@swc/helpers/esm/_iterable_to_array.js","node_modules/@swc/helpers/esm/_non_iterable_spread.js","packages/music/src/index.ts","packages/music/src/math.ts","packages/music/src/theory.ts","packages/music/src/rhythm.ts","packages/music/src/common.ts","node_modules/ramda/es/clone.js","node_modules/ramda/es/internal/_clone.js","node_modules/@swc/helpers/esm/_type_of.js","node_modules/ramda/es/internal/_cloneRegExp.js","node_modules/ramda/es/type.js","node_modules/ramda/es/internal/_curry1.js","node_modules/ramda/es/internal/_isPlaceholder.js"],"sourcesContent":["(function () {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $3c215dd1e12969fd$exports = {};\n\n$parcel$export($3c215dd1e12969fd$exports, \"TickType\", function () { return $3c215dd1e12969fd$export$2cd96fc3b1b618d8; });\n$parcel$export($3c215dd1e12969fd$exports, \"startTask\", function () { return $3c215dd1e12969fd$export$1c43efaafc52b831; });\n$parcel$export($3c215dd1e12969fd$exports, \"stopTask\", function () { return $3c215dd1e12969fd$export$d9d592371c2a2f98; });\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function $e39263bbdcb7d3f2$export$685354647fba1516() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\n\nfunction $ade657966c9f3425$export$c2c98ac76e997b63(o, p) {\n    $ade657966c9f3425$export$c2c98ac76e997b63 = Object.setPrototypeOf || function setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return $ade657966c9f3425$export$c2c98ac76e997b63(o, p);\n}\n\n\nfunction $9e42a30d1410267f$export$2d841144c5f8c4ab(Parent, args, Class) {\n    if ((0, $e39263bbdcb7d3f2$export$685354647fba1516)()) $9e42a30d1410267f$export$2d841144c5f8c4ab = Reflect.construct;\n    else $9e42a30d1410267f$export$2d841144c5f8c4ab = function construct(Parent, args, Class) {\n        var a = [\n            null\n        ];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) (0, $ade657966c9f3425$export$c2c98ac76e997b63)(instance, Class.prototype);\n        return instance;\n    };\n    return $9e42a30d1410267f$export$2d841144c5f8c4ab.apply(null, arguments);\n}\n\n\nfunction $e70e36fe5deea41b$export$1e71eb4bef00f6b0(obj, key, value) {\n    if (key in obj) Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    });\n    else obj[key] = value;\n    return obj;\n}\n\n\nfunction $a1cd44da124c2e18$export$e6256bf45c68d561(arr) {\n    if (Array.isArray(arr)) return arr;\n}\n\n\nfunction $c99b99ae29b851d2$export$2fd15edff6687200(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\n\n\nfunction $2981ef585d9b3ce6$export$60dbc22abd7da546() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n\nfunction $e1771364af16df86$export$79e617b1955a2616(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\n\n\nfunction $4d2bd7d199d3d5af$export$a5be06335b3a083c(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return (0, $e1771364af16df86$export$79e617b1955a2616)(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0, $e1771364af16df86$export$79e617b1955a2616)(o, minLen);\n}\n\n\nfunction $35211f8b9a4957d2$export$fdf2a89c76341bbf(arr, i) {\n    return (0, $a1cd44da124c2e18$export$e6256bf45c68d561)(arr) || (0, $c99b99ae29b851d2$export$2fd15edff6687200)(arr, i) || (0, $4d2bd7d199d3d5af$export$a5be06335b3a083c)(arr, i) || (0, $2981ef585d9b3ce6$export$60dbc22abd7da546)();\n}\n\n\n\nfunction $2b9e2a47f112feae$export$7e0947b5ad3404e2(arr) {\n    if (Array.isArray(arr)) return (0, $e1771364af16df86$export$79e617b1955a2616)(arr);\n}\n\n\nfunction $9f1d3dc1e3ce8ee2$export$1eb58a6e75231000(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\n\nfunction $8a0f3ad6f4d43861$export$e6f3c4780d19eb2b() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n\n\nfunction $129d079e0dffb367$export$1b5e630bc3aea29f(arr) {\n    return (0, $2b9e2a47f112feae$export$7e0947b5ad3404e2)(arr) || (0, $9f1d3dc1e3ce8ee2$export$1eb58a6e75231000)(arr) || (0, $4d2bd7d199d3d5af$export$a5be06335b3a083c)(arr) || (0, $8a0f3ad6f4d43861$export$e6f3c4780d19eb2b)();\n}\n\n\nvar $b354d50e5cbd063c$export$be5234c0b764b6e0 = Symbol(\"Comlink.proxy\");\nvar $b354d50e5cbd063c$export$39fb953702b7fcd7 = Symbol(\"Comlink.endpoint\");\nvar $b354d50e5cbd063c$export$89981d4b8d9f48aa = Symbol(\"Comlink.releaseProxy\");\nvar $b354d50e5cbd063c$export$ddc31dfe7c269837 = Symbol(\"Comlink.finalizer\");\nvar $b354d50e5cbd063c$var$throwMarker = Symbol(\"Comlink.thrown\");\nvar $b354d50e5cbd063c$var$isObject = function(val) {\n    return typeof val === \"object\" && val !== null || typeof val === \"function\";\n};\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */ var $b354d50e5cbd063c$var$proxyTransferHandler = {\n    canHandle: function(val) {\n        return $b354d50e5cbd063c$var$isObject(val) && val[$b354d50e5cbd063c$export$be5234c0b764b6e0];\n    },\n    serialize: function(obj) {\n        var _ref = new MessageChannel(), port1 = _ref.port1, port2 = _ref.port2;\n        $b354d50e5cbd063c$export$9b7f6e342a8cbd38(obj, port1);\n        return [\n            port2,\n            [\n                port2\n            ]\n        ];\n    },\n    deserialize: function(port) {\n        port.start();\n        return $b354d50e5cbd063c$export$4997ffc0176396a6(port);\n    }\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */ var $b354d50e5cbd063c$var$throwTransferHandler = {\n    canHandle: function(value) {\n        return $b354d50e5cbd063c$var$isObject(value) && $b354d50e5cbd063c$var$throwMarker in value;\n    },\n    serialize: function(param) {\n        var value = param.value;\n        var serialized;\n        if (value instanceof Error) serialized = {\n            isError: true,\n            value: {\n                message: value.message,\n                name: value.name,\n                stack: value.stack\n            }\n        };\n        else serialized = {\n            isError: false,\n            value: value\n        };\n        return [\n            serialized,\n            []\n        ];\n    },\n    deserialize: function(serialized) {\n        if (serialized.isError) throw Object.assign(new Error(serialized.value.message), serialized.value);\n        throw serialized.value;\n    }\n};\n/**\n * Allows customizing the serialization of certain values.\n */ var $b354d50e5cbd063c$export$ab8f1c00731ee83e = new Map([\n    [\n        \"proxy\",\n        $b354d50e5cbd063c$var$proxyTransferHandler\n    ],\n    [\n        \"throw\",\n        $b354d50e5cbd063c$var$throwTransferHandler\n    ]\n]);\nfunction $b354d50e5cbd063c$var$isAllowedOrigin(allowedOrigins, origin) {\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = allowedOrigins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var allowedOrigin = _step.value;\n            if (origin === allowedOrigin || allowedOrigin === \"*\") return true;\n            if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) return true;\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return false;\n}\nfunction $b354d50e5cbd063c$export$9b7f6e342a8cbd38(obj) {\n    var ep = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : globalThis, allowedOrigins = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [\n        \"*\"\n    ];\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) return;\n        if (!$b354d50e5cbd063c$var$isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(\"Invalid origin '\".concat(ev.origin, \"' for comlink proxy\"));\n            return;\n        }\n        var _Object_assign = Object.assign({\n            path: []\n        }, ev.data), id = _Object_assign.id, type = _Object_assign.type, path = _Object_assign.path;\n        var argumentList = (ev.data.argumentList || []).map($b354d50e5cbd063c$var$fromWireValue);\n        var returnValue;\n        try {\n            var parent = path.slice(0, -1).reduce(function(obj, prop) {\n                return obj[prop];\n            }, obj);\n            var rawValue = path.reduce(function(obj, prop) {\n                return obj[prop];\n            }, obj);\n            switch(type){\n                case \"GET\" /* MessageType.GET */ :\n                    returnValue = rawValue;\n                    break;\n                case \"SET\" /* MessageType.SET */ :\n                    parent[path.slice(-1)[0]] = $b354d50e5cbd063c$var$fromWireValue(ev.data.value);\n                    returnValue = true;\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */ :\n                    returnValue = rawValue.apply(parent, argumentList);\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */ :\n                    {\n                        var _$value = (0, $9e42a30d1410267f$export$2d841144c5f8c4ab)(rawValue, (0, $129d079e0dffb367$export$1b5e630bc3aea29f)(argumentList));\n                        returnValue = $b354d50e5cbd063c$export$923f96dd5afa9ce6(_$value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */ :\n                    {\n                        var _ref = new MessageChannel(), port1 = _ref.port1, port2 = _ref.port2;\n                        $b354d50e5cbd063c$export$9b7f6e342a8cbd38(obj, port2);\n                        returnValue = $b354d50e5cbd063c$export$c9b234447cf4ef7c(port1, [\n                            port1\n                        ]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */ :\n                    returnValue = undefined;\n                    break;\n                default:\n                    return;\n            }\n        } catch (value) {\n            returnValue = (0, $e70e36fe5deea41b$export$1e71eb4bef00f6b0)({\n                value: value\n            }, $b354d50e5cbd063c$var$throwMarker, 0);\n        }\n        Promise.resolve(returnValue)[\"catch\"](function(value) {\n            return (0, $e70e36fe5deea41b$export$1e71eb4bef00f6b0)({\n                value: value\n            }, $b354d50e5cbd063c$var$throwMarker, 0);\n        }).then(function(returnValue) {\n            var _toWireValue = (0, $35211f8b9a4957d2$export$fdf2a89c76341bbf)($b354d50e5cbd063c$var$toWireValue(returnValue), 2), wireValue = _toWireValue[0], transferables = _toWireValue[1];\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n                id: id\n            }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */ ) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                $b354d50e5cbd063c$var$closeEndPoint(ep);\n                if ($b354d50e5cbd063c$export$ddc31dfe7c269837 in obj && typeof obj[$b354d50e5cbd063c$export$ddc31dfe7c269837] === \"function\") obj[$b354d50e5cbd063c$export$ddc31dfe7c269837]();\n            }\n        })[\"catch\"](function(error) {\n            // Send Serialization Error To Caller\n            var _toWireValue = (0, $35211f8b9a4957d2$export$fdf2a89c76341bbf)($b354d50e5cbd063c$var$toWireValue((0, $e70e36fe5deea41b$export$1e71eb4bef00f6b0)({\n                value: new TypeError(\"Unserializable return value\")\n            }, $b354d50e5cbd063c$var$throwMarker, 0)), 2), wireValue = _toWireValue[0], transferables = _toWireValue[1];\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n                id: id\n            }), transferables);\n        });\n    });\n    if (ep.start) ep.start();\n}\nfunction $b354d50e5cbd063c$var$isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction $b354d50e5cbd063c$var$closeEndPoint(endpoint) {\n    if ($b354d50e5cbd063c$var$isMessagePort(endpoint)) endpoint.close();\n}\nfunction $b354d50e5cbd063c$export$4997ffc0176396a6(ep, target) {\n    return $b354d50e5cbd063c$var$createProxy(ep, [], target);\n}\nfunction $b354d50e5cbd063c$var$throwIfProxyReleased(isReleased) {\n    if (isReleased) throw new Error(\"Proxy has been released and is not useable\");\n}\nfunction $b354d50e5cbd063c$var$releaseEndpoint(ep) {\n    return $b354d50e5cbd063c$var$requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */ \n    }).then(function() {\n        $b354d50e5cbd063c$var$closeEndPoint(ep);\n    });\n}\nvar $b354d50e5cbd063c$var$proxyCounter = new WeakMap();\nvar $b354d50e5cbd063c$var$proxyFinalizers = \"FinalizationRegistry\" in globalThis && new FinalizationRegistry(function(ep) {\n    var newCount = ($b354d50e5cbd063c$var$proxyCounter.get(ep) || 0) - 1;\n    $b354d50e5cbd063c$var$proxyCounter.set(ep, newCount);\n    if (newCount === 0) $b354d50e5cbd063c$var$releaseEndpoint(ep);\n});\nfunction $b354d50e5cbd063c$var$registerProxy(proxy, ep) {\n    var newCount = ($b354d50e5cbd063c$var$proxyCounter.get(ep) || 0) + 1;\n    $b354d50e5cbd063c$var$proxyCounter.set(ep, newCount);\n    if ($b354d50e5cbd063c$var$proxyFinalizers) $b354d50e5cbd063c$var$proxyFinalizers.register(proxy, ep, proxy);\n}\nfunction $b354d50e5cbd063c$var$unregisterProxy(proxy) {\n    if ($b354d50e5cbd063c$var$proxyFinalizers) $b354d50e5cbd063c$var$proxyFinalizers.unregister(proxy);\n}\nfunction $b354d50e5cbd063c$var$createProxy(ep) {\n    var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {};\n    var isProxyReleased = false;\n    var proxy = new Proxy(target, {\n        get: function(_target, prop) {\n            $b354d50e5cbd063c$var$throwIfProxyReleased(isProxyReleased);\n            if (prop === $b354d50e5cbd063c$export$89981d4b8d9f48aa) return function() {\n                $b354d50e5cbd063c$var$unregisterProxy(proxy);\n                $b354d50e5cbd063c$var$releaseEndpoint(ep);\n                isProxyReleased = true;\n            };\n            if (prop === \"then\") {\n                if (path.length === 0) return {\n                    then: function() {\n                        return proxy;\n                    }\n                };\n                var r = $b354d50e5cbd063c$var$requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */ ,\n                    path: path.map(function(p) {\n                        return p.toString();\n                    })\n                }).then($b354d50e5cbd063c$var$fromWireValue);\n                return r.then.bind(r);\n            }\n            return $b354d50e5cbd063c$var$createProxy(ep, (0, $129d079e0dffb367$export$1b5e630bc3aea29f)(path).concat([\n                prop\n            ]));\n        },\n        set: function(_target, prop, rawValue) {\n            $b354d50e5cbd063c$var$throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            var _toWireValue = (0, $35211f8b9a4957d2$export$fdf2a89c76341bbf)($b354d50e5cbd063c$var$toWireValue(rawValue), 2), value = _toWireValue[0], transferables = _toWireValue[1];\n            return $b354d50e5cbd063c$var$requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */ ,\n                path: (0, $129d079e0dffb367$export$1b5e630bc3aea29f)(path).concat([\n                    prop\n                ]).map(function(p) {\n                    return p.toString();\n                }),\n                value: value\n            }, transferables).then($b354d50e5cbd063c$var$fromWireValue);\n        },\n        apply: function(_target, _thisArg, rawArgumentList) {\n            $b354d50e5cbd063c$var$throwIfProxyReleased(isProxyReleased);\n            var last = path[path.length - 1];\n            if (last === $b354d50e5cbd063c$export$39fb953702b7fcd7) return $b354d50e5cbd063c$var$requestResponseMessage(ep, {\n                type: \"ENDPOINT\" /* MessageType.ENDPOINT */ \n            }).then($b354d50e5cbd063c$var$fromWireValue);\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") return $b354d50e5cbd063c$var$createProxy(ep, path.slice(0, -1));\n            var _processArguments = (0, $35211f8b9a4957d2$export$fdf2a89c76341bbf)($b354d50e5cbd063c$var$processArguments(rawArgumentList), 2), argumentList = _processArguments[0], transferables = _processArguments[1];\n            return $b354d50e5cbd063c$var$requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */ ,\n                path: path.map(function(p) {\n                    return p.toString();\n                }),\n                argumentList: argumentList\n            }, transferables).then($b354d50e5cbd063c$var$fromWireValue);\n        },\n        construct: function(_target, rawArgumentList) {\n            $b354d50e5cbd063c$var$throwIfProxyReleased(isProxyReleased);\n            var _processArguments = (0, $35211f8b9a4957d2$export$fdf2a89c76341bbf)($b354d50e5cbd063c$var$processArguments(rawArgumentList), 2), argumentList = _processArguments[0], transferables = _processArguments[1];\n            return $b354d50e5cbd063c$var$requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */ ,\n                path: path.map(function(p) {\n                    return p.toString();\n                }),\n                argumentList: argumentList\n            }, transferables).then($b354d50e5cbd063c$var$fromWireValue);\n        }\n    });\n    $b354d50e5cbd063c$var$registerProxy(proxy, ep);\n    return proxy;\n}\nfunction $b354d50e5cbd063c$var$myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction $b354d50e5cbd063c$var$processArguments(argumentList) {\n    var processed = argumentList.map($b354d50e5cbd063c$var$toWireValue);\n    return [\n        processed.map(function(v) {\n            return v[0];\n        }),\n        $b354d50e5cbd063c$var$myFlat(processed.map(function(v) {\n            return v[1];\n        }))\n    ];\n}\nvar $b354d50e5cbd063c$var$transferCache = new WeakMap();\nfunction $b354d50e5cbd063c$export$c9b234447cf4ef7c(obj, transfers) {\n    $b354d50e5cbd063c$var$transferCache.set(obj, transfers);\n    return obj;\n}\nfunction $b354d50e5cbd063c$export$923f96dd5afa9ce6(obj) {\n    return Object.assign(obj, (0, $e70e36fe5deea41b$export$1e71eb4bef00f6b0)({}, $b354d50e5cbd063c$export$be5234c0b764b6e0, true));\n}\nfunction $b354d50e5cbd063c$export$f2c03fb5a6c19546(w) {\n    var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : globalThis, targetOrigin = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"*\";\n    return {\n        postMessage: function(msg, transferables) {\n            return w.postMessage(msg, targetOrigin, transferables);\n        },\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context)\n    };\n}\nfunction $b354d50e5cbd063c$var$toWireValue(value) {\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = $b354d50e5cbd063c$export$ab8f1c00731ee83e[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var _step_value = (0, $35211f8b9a4957d2$export$fdf2a89c76341bbf)(_step.value, 2), name = _step_value[0], handler = _step_value[1];\n            if (handler.canHandle(value)) {\n                var _handler_serialize = (0, $35211f8b9a4957d2$export$fdf2a89c76341bbf)(handler.serialize(value), 2), serializedValue = _handler_serialize[0], transferables = _handler_serialize[1];\n                return [\n                    {\n                        type: \"HANDLER\" /* WireValueType.HANDLER */ ,\n                        name: name,\n                        value: serializedValue\n                    },\n                    transferables\n                ];\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */ ,\n            value: value\n        },\n        $b354d50e5cbd063c$var$transferCache.get(value) || []\n    ];\n}\nfunction $b354d50e5cbd063c$var$fromWireValue(value) {\n    switch(value.type){\n        case \"HANDLER\" /* WireValueType.HANDLER */ :\n            return $b354d50e5cbd063c$export$ab8f1c00731ee83e.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */ :\n            return value.value;\n    }\n}\nfunction $b354d50e5cbd063c$var$requestResponseMessage(ep, msg, transfers) {\n    return new Promise(function(resolve) {\n        var id = $b354d50e5cbd063c$var$generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) return;\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) ep.start();\n        ep.postMessage(Object.assign({\n            id: id\n        }, msg), transfers);\n    });\n}\nfunction $b354d50e5cbd063c$var$generateUUID() {\n    return new Array(4).fill(0).map(function() {\n        return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16);\n    }).join(\"-\");\n}\n\n\nfunction $4c23d83373745e4f$export$f81847884871263e(num1, num2) {\n    if (num1 % num2 == 0) return num2;\n    else return $4c23d83373745e4f$export$f81847884871263e(num2, num1 % num2);\n}\nfunction $4c23d83373745e4f$export$f686d97e407ec4ef(num1, num2) {\n    if (num1 === 0) return num2;\n    if (num2 === 0) return num1;\n    return num1 * num2 / $4c23d83373745e4f$export$f81847884871263e(num1, num2);\n}\n\n\nvar $515cd16560c8c62d$export$df409b90d2c1a310;\n(function(Dynamics) {\n    Dynamics[Dynamics[\"None\"] = 0] = \"None\";\n    Dynamics[Dynamics[\"Light\"] = 1] = \"Light\";\n    Dynamics[Dynamics[\"Accent\"] = 2] = \"Accent\";\n    Dynamics[Dynamics[\"Invalid\"] = 3] = \"Invalid\";\n})($515cd16560c8c62d$export$df409b90d2c1a310 || ($515cd16560c8c62d$export$df409b90d2c1a310 = {}));\nvar $515cd16560c8c62d$export$2050b8129d8cdad6;\n(function(NoteName) {\n    NoteName[NoteName[\"C\"] = 0] = \"C\";\n    NoteName[NoteName[\"CSharp\"] = 1] = \"CSharp\";\n    NoteName[NoteName[\"D\"] = 2] = \"D\";\n    NoteName[NoteName[\"DSharp\"] = 3] = \"DSharp\";\n    NoteName[NoteName[\"E\"] = 4] = \"E\";\n    NoteName[NoteName[\"F\"] = 5] = \"F\";\n    NoteName[NoteName[\"FSharp\"] = 6] = \"FSharp\";\n    NoteName[NoteName[\"G\"] = 7] = \"G\";\n    NoteName[NoteName[\"GSharp\"] = 8] = \"GSharp\";\n    NoteName[NoteName[\"A\"] = 9] = \"A\";\n    NoteName[NoteName[\"ASharp\"] = 10] = \"ASharp\";\n    NoteName[NoteName[\"B\"] = 11] = \"B\";\n})($515cd16560c8c62d$export$2050b8129d8cdad6 || ($515cd16560c8c62d$export$2050b8129d8cdad6 = {}));\n\n\n\nvar $3b58820c336922e8$export$ed30250e7522198 = {\n    type: \"uniform\",\n    speed: 60\n};\nvar $3b58820c336922e8$export$f045ecc4aca1fdee = {\n    type: \"varying\",\n    begin: 60,\n    end: 60,\n    step: 10\n};\nvar $3b58820c336922e8$export$e98fdd653f95b0e8 = {\n    name: (0, $515cd16560c8c62d$export$2050b8129d8cdad6).A,\n    octave: 4,\n    dynamics: (0, $515cd16560c8c62d$export$df409b90d2c1a310).Accent\n};\nvar $3b58820c336922e8$export$a46cd66499351d28 = {\n    name: (0, $515cd16560c8c62d$export$2050b8129d8cdad6).A,\n    octave: 4,\n    dynamics: (0, $515cd16560c8c62d$export$df409b90d2c1a310).Light\n};\nvar $3b58820c336922e8$export$7f74fb282b451e4b = [\n    {\n        repeat: 1,\n        beats: [\n            {\n                notes: [\n                    $3b58820c336922e8$export$e98fdd653f95b0e8\n                ]\n            },\n            {\n                notes: [\n                    $3b58820c336922e8$export$a46cd66499351d28\n                ]\n            },\n            {\n                notes: [\n                    $3b58820c336922e8$export$a46cd66499351d28\n                ]\n            },\n            {\n                notes: [\n                    $3b58820c336922e8$export$a46cd66499351d28\n                ]\n            },\n            {\n                notes: [\n                    $3b58820c336922e8$export$e98fdd653f95b0e8\n                ]\n            },\n            {\n                notes: [\n                    $3b58820c336922e8$export$a46cd66499351d28\n                ]\n            },\n            {\n                notes: [\n                    $3b58820c336922e8$export$a46cd66499351d28\n                ]\n            },\n            {\n                notes: [\n                    $3b58820c336922e8$export$a46cd66499351d28\n                ]\n            }\n        ]\n    }\n];\nvar $3b58820c336922e8$export$95e97a0b2b64af93 = {\n    name: (0, $515cd16560c8c62d$export$2050b8129d8cdad6).A,\n    octave: 4,\n    dynamics: (0, $515cd16560c8c62d$export$df409b90d2c1a310).None\n};\nvar $3b58820c336922e8$export$7dbade755bbd7df5 = 440; // A4\nfunction $3b58820c336922e8$export$9c8164e79773c764(noteName) {\n    switch(noteName){\n        case (0, $515cd16560c8c62d$export$2050b8129d8cdad6).C:\n            return \"C\";\n        case (0, $515cd16560c8c62d$export$2050b8129d8cdad6).CSharp:\n            return \"C#\";\n        case (0, $515cd16560c8c62d$export$2050b8129d8cdad6).D:\n            return \"D\";\n        case (0, $515cd16560c8c62d$export$2050b8129d8cdad6).DSharp:\n            return \"D#\";\n        case (0, $515cd16560c8c62d$export$2050b8129d8cdad6).E:\n            return \"E\";\n        case (0, $515cd16560c8c62d$export$2050b8129d8cdad6).F:\n            return \"F\";\n        case (0, $515cd16560c8c62d$export$2050b8129d8cdad6).FSharp:\n            return \"F#\";\n        case (0, $515cd16560c8c62d$export$2050b8129d8cdad6).G:\n            return \"G\";\n        case (0, $515cd16560c8c62d$export$2050b8129d8cdad6).GSharp:\n            return \"G#\";\n        case (0, $515cd16560c8c62d$export$2050b8129d8cdad6).A:\n            return \"A\";\n        case (0, $515cd16560c8c62d$export$2050b8129d8cdad6).ASharp:\n            return \"A#\";\n        case (0, $515cd16560c8c62d$export$2050b8129d8cdad6).B:\n            return \"B\";\n    }\n}\nfunction $3b58820c336922e8$export$e30cdbfc5f0ca703(note) {\n    return \"\".concat($3b58820c336922e8$export$9c8164e79773c764(note.name)).concat(note.octave);\n}\nfunction $3b58820c336922e8$export$791af547312e0674(noteA, noteB) {\n    return 12 * (noteA.octave - noteB.octave) + (noteA.name - noteB.name);\n}\nfunction $3b58820c336922e8$export$a8f9b7b280712859(note) {\n    var halfSteps = $3b58820c336922e8$export$791af547312e0674(note, $3b58820c336922e8$export$95e97a0b2b64af93);\n    return Math.pow(2, halfSteps / 12) * $3b58820c336922e8$export$7dbade755bbd7df5;\n}\nfunction $3b58820c336922e8$export$6f9f24d921645b42(frequency, dynamics) {\n    var halfSteps = Math.round(Math.log(frequency / $3b58820c336922e8$export$7dbade755bbd7df5) * 12 / Math.log(2)) - ((0, $515cd16560c8c62d$export$2050b8129d8cdad6).C - (0, $515cd16560c8c62d$export$2050b8129d8cdad6).A);\n    var octave = Math.floor(halfSteps / 12) + $3b58820c336922e8$export$95e97a0b2b64af93.octave;\n    var name = (halfSteps - (octave - $3b58820c336922e8$export$95e97a0b2b64af93.octave) * 12) % ((0, $515cd16560c8c62d$export$2050b8129d8cdad6).B + 1);\n    return {\n        name: name,\n        octave: octave,\n        dynamics: dynamics\n    };\n}\nfunction $3b58820c336922e8$export$ee00045eeaf37fbc(audioBuffer, sampleRate) {\n    var audioSize = audioBuffer.length;\n    var rms = 0;\n    for(var i = 0; i < audioSize; i++){\n        var val = audioBuffer[i];\n        rms += val * val;\n    }\n    rms = Math.sqrt(rms / audioSize);\n    if (rms < 0.01) return -1;\n    var startIndex = 0;\n    var endIndex = audioSize - 1;\n    var threshold = 0.2;\n    for(var i1 = 0; i1 < audioSize / 2; i1++)if (Math.abs(audioBuffer[i1]) < threshold) {\n        startIndex = i1;\n        break;\n    }\n    for(var i2 = 1; i2 < audioSize / 2; i2++)if (Math.abs(audioBuffer[audioSize - i2]) < threshold) {\n        endIndex = audioSize - i2;\n        break;\n    }\n    var audioSlice = audioBuffer.slice(startIndex, endIndex);\n    var sliceSize = audioSlice.length;\n    var c = new Array(sliceSize).fill(0);\n    for(var i3 = 0; i3 < sliceSize; i3++)for(var j = 0; j < sliceSize - i3; j++)c[i3] = c[i3] + audioSlice[j] * audioSlice[j + i3];\n    var d = 0;\n    while(c[d] > c[d + 1])d++;\n    var maxval = -1;\n    var maxpos = -1;\n    for(var i4 = d; i4 < sliceSize; i4++)if (c[i4] > maxval) {\n        maxval = c[i4];\n        maxpos = i4;\n    }\n    var T0 = maxpos;\n    var x1 = c[T0 - 1];\n    var x2 = c[T0];\n    var x3 = c[T0 + 1];\n    var a = (x1 + x3 - 2 * x2) / 2;\n    var b = (x3 - x1) / 2;\n    if (a) T0 = T0 - b / (2 * a);\n    return sampleRate / T0;\n}\n\n\n\n\nfunction $6a12ece08b8f7a2f$export$5f0017c582d45a2d(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\n\n\nfunction $44ad44b65ae393c1$export$2e2bcd8739ae039(pattern) {\n    return new RegExp(pattern.source, pattern.flags ? pattern.flags : (pattern.global ? \"g\" : \"\") + (pattern.ignoreCase ? \"i\" : \"\") + (pattern.multiline ? \"m\" : \"\") + (pattern.sticky ? \"y\" : \"\") + (pattern.unicode ? \"u\" : \"\") + (pattern.dotAll ? \"s\" : \"\"));\n}\n\n\nfunction $cf821780e04814f5$export$2e2bcd8739ae039(a) {\n    return a != null && typeof a === \"object\" && a[\"@@functional/placeholder\"] === true;\n}\n\n\nfunction $85d22d3377c7225f$export$2e2bcd8739ae039(fn) {\n    return function f1(a) {\n        if (arguments.length === 0 || (0, $cf821780e04814f5$export$2e2bcd8739ae039)(a)) return f1;\n        else return fn.apply(this, arguments);\n    };\n}\n\n\n/**\n * Gives a single-word string description of the (native) type of a value,\n * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not\n * attempt to distinguish user Object types any further, reporting them all as\n * 'Object'.\n *\n * @func\n * @memberOf R\n * @since v0.8.0\n * @category Type\n * @sig * -> String\n * @param {*} val The value to test\n * @return {String}\n * @example\n *\n *      R.type({}); //=> \"Object\"\n *      R.type(1); //=> \"Number\"\n *      R.type(false); //=> \"Boolean\"\n *      R.type('s'); //=> \"String\"\n *      R.type(null); //=> \"Null\"\n *      R.type([]); //=> \"Array\"\n *      R.type(/[A-z]/); //=> \"RegExp\"\n *      R.type(() => {}); //=> \"Function\"\n *      R.type(async () => {}); //=> \"AsyncFunction\"\n *      R.type(undefined); //=> \"Undefined\"\n */ var $b087867b37ef61b5$var$type = /*#__PURE__*/ (0, $85d22d3377c7225f$export$2e2bcd8739ae039)(function type(val) {\n    return val === null ? \"Null\" : val === undefined ? \"Undefined\" : Object.prototype.toString.call(val).slice(8, -1);\n});\nvar $b087867b37ef61b5$export$2e2bcd8739ae039 = $b087867b37ef61b5$var$type;\n\n\nfunction $a2c4a29d1980f51b$export$2e2bcd8739ae039(value, deep, map) {\n    map || (map = new $a2c4a29d1980f51b$var$_ObjectMap()); // this avoids the slower switch with a quick if decision removing some milliseconds in each run.\n    if ($a2c4a29d1980f51b$var$_isPrimitive(value)) return value;\n    var copy = function copy(copiedValue) {\n        // Check for circular and same references on the object graph and return its corresponding clone.\n        var cachedCopy = map.get(value);\n        if (cachedCopy) return cachedCopy;\n        map.set(value, copiedValue);\n        for(var key in value)if (Object.prototype.hasOwnProperty.call(value, key)) copiedValue[key] = deep ? $a2c4a29d1980f51b$export$2e2bcd8739ae039(value[key], true, map) : value[key];\n        return copiedValue;\n    };\n    switch((0, $b087867b37ef61b5$export$2e2bcd8739ae039)(value)){\n        case \"Object\":\n            return copy(Object.create(Object.getPrototypeOf(value)));\n        case \"Array\":\n            return copy([]);\n        case \"Date\":\n            return new Date(value.valueOf());\n        case \"RegExp\":\n            return (0, $44ad44b65ae393c1$export$2e2bcd8739ae039)(value);\n        case \"Int8Array\":\n        case \"Uint8Array\":\n        case \"Uint8ClampedArray\":\n        case \"Int16Array\":\n        case \"Uint16Array\":\n        case \"Int32Array\":\n        case \"Uint32Array\":\n        case \"Float32Array\":\n        case \"Float64Array\":\n        case \"BigInt64Array\":\n        case \"BigUint64Array\":\n            return value.slice();\n        default:\n            return value;\n    }\n}\nfunction $a2c4a29d1980f51b$var$_isPrimitive(param) {\n    var type = typeof param === \"undefined\" ? \"undefined\" : (0, $6a12ece08b8f7a2f$export$5f0017c582d45a2d)(param);\n    return param == null || type != \"object\" && type != \"function\";\n}\nvar $a2c4a29d1980f51b$var$_ObjectMap = /*#__PURE__*/ function() {\n    function _ObjectMap() {\n        this.map = {};\n        this.length = 0;\n    }\n    _ObjectMap.prototype.set = function(key, value) {\n        var hashedKey = this.hash(key);\n        var bucket = this.map[hashedKey];\n        if (!bucket) this.map[hashedKey] = bucket = [];\n        bucket.push([\n            key,\n            value\n        ]);\n        this.length += 1;\n    };\n    _ObjectMap.prototype.hash = function(key) {\n        var hashedKey = [];\n        for(var value in key)hashedKey.push(Object.prototype.toString.call(key[value]));\n        return hashedKey.join();\n    };\n    _ObjectMap.prototype.get = function(key) {\n        /**\n     * depending on the number of objects to be cloned is faster to just iterate over the items in the map just because the hash function is so costly,\n     * on my tests this number is 180, anything above that using the hash function is faster.\n     */ if (this.length <= 180) {\n            for(var p in this.map){\n                var bucket = this.map[p];\n                for(var i = 0; i < bucket.length; i += 1){\n                    var element = bucket[i];\n                    if (element[0] === key) return element[1];\n                }\n            }\n            return;\n        }\n        var hashedKey = this.hash(key);\n        var bucket1 = this.map[hashedKey];\n        if (!bucket1) return;\n        for(var i1 = 0; i1 < bucket1.length; i1 += 1){\n            var element1 = bucket1[i1];\n            if (element1[0] === key) return element1[1];\n        }\n    };\n    return _ObjectMap;\n}();\n\n\n\n/**\n * Creates a deep copy of the source that can be used in place of the source\n * object without retaining any references to it.\n * The source object may contain (nested) `Array`s and `Object`s,\n * `Number`s, `String`s, `Boolean`s and `Date`s.\n * `Function`s are assigned by reference rather than copied.\n *\n * Dispatches to a `clone` method if present.\n *\n * Note that if the source object has multiple nodes that share a reference,\n * the returned object will have the same structure, but the references will\n * be pointed to the location within the cloned value.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @sig {*} -> {*}\n * @param {*} value The object or array to clone\n * @return {*} A deeply cloned copy of `val`\n * @example\n *\n *      const objects = [{}, {}, {}];\n *      const objectsClone = R.clone(objects);\n *      objects === objectsClone; //=> false\n *      objects[0] === objectsClone[0]; //=> false\n */ var $be292f1a03c535f7$var$clone = /*#__PURE__*/ (0, $85d22d3377c7225f$export$2e2bcd8739ae039)(function clone(value) {\n    return value != null && typeof value.clone === \"function\" ? value.clone() : (0, $a2c4a29d1980f51b$export$2e2bcd8739ae039)(value, true);\n});\nvar $be292f1a03c535f7$export$2e2bcd8739ae039 = $be292f1a03c535f7$var$clone;\n\n\nfunction $a0e9c665509477f7$export$4305c4a638586d94(tempo) {\n    return $be292f1a03c535f7$export$2e2bcd8739ae039(tempo);\n}\nfunction $a0e9c665509477f7$export$53eb9750d527b0ce(note) {\n    return $be292f1a03c535f7$export$2e2bcd8739ae039(note);\n}\nfunction $a0e9c665509477f7$export$d96ce701b5cbe4ed(beat) {\n    return $be292f1a03c535f7$export$2e2bcd8739ae039(beat);\n}\nfunction $a0e9c665509477f7$export$f96da437e9862c2f(measure) {\n    return $be292f1a03c535f7$export$2e2bcd8739ae039(measure);\n}\nfunction $a0e9c665509477f7$export$85510b841f5c59b9(rhythm) {\n    return $be292f1a03c535f7$export$2e2bcd8739ae039(rhythm);\n}\nfunction $a0e9c665509477f7$export$626701cf3387d96f(rhythm, preparatory) {\n    var newRhythm = $a0e9c665509477f7$export$85510b841f5c59b9(rhythm);\n    newRhythm.preparatoryBeats = preparatory;\n    return newRhythm;\n}\nfunction $a0e9c665509477f7$export$14dbe7bbd606b84a(rhythm, tempo) {\n    var newRhythm = $a0e9c665509477f7$export$85510b841f5c59b9(rhythm);\n    newRhythm.tempo = $a0e9c665509477f7$export$4305c4a638586d94(tempo);\n    return newRhythm;\n}\nfunction $a0e9c665509477f7$export$8abb4dd589a611d(rhythm) {\n    var newRhythm = $a0e9c665509477f7$export$85510b841f5c59b9(rhythm);\n    var lastMeasure = newRhythm.measures[rhythm.measures.length - 1];\n    if (lastMeasure) newRhythm.measures.push($a0e9c665509477f7$export$f96da437e9862c2f(lastMeasure));\n    else newRhythm.measures = (0, $3b58820c336922e8$export$7f74fb282b451e4b);\n    return newRhythm;\n}\nfunction $a0e9c665509477f7$export$21f3df343fa13a46(rhythm, measureIndex) {\n    var newRhythm = $a0e9c665509477f7$export$85510b841f5c59b9(rhythm);\n    newRhythm.measures.splice(measureIndex, 1);\n    return newRhythm;\n}\nfunction $a0e9c665509477f7$export$a2bc369da6b0184b(rhythm, measureIndex, repeat) {\n    var newRhythm = $a0e9c665509477f7$export$85510b841f5c59b9(rhythm);\n    var measure = newRhythm.measures[measureIndex];\n    if (measure) measure.repeat = repeat;\n    return newRhythm;\n}\nfunction $a0e9c665509477f7$export$830fa49c40093bd5(rhythm, measureIndex) {\n    var newRhythm = $a0e9c665509477f7$export$85510b841f5c59b9(rhythm);\n    var measure = newRhythm.measures[measureIndex];\n    if (measure) {\n        var beat = measure.beats[measure.beats.length - 1];\n        if (beat) measure.beats.push($a0e9c665509477f7$export$d96ce701b5cbe4ed(beat));\n    }\n    return newRhythm;\n}\nfunction $a0e9c665509477f7$export$9387a39c06a193e3(rhythm, measureIndex) {\n    var newRhythm = $a0e9c665509477f7$export$85510b841f5c59b9(rhythm);\n    var measure = newRhythm.measures[measureIndex];\n    if (measure) {\n        measure.beats = measure.beats.slice(0, measure.beats.length - 1);\n        if (measure.beats.length === 0) newRhythm.measures.splice(measureIndex, 1);\n    }\n    return newRhythm;\n}\nfunction $a0e9c665509477f7$export$79159e21a6bceab7(rhythm, measureIndex, beatIndex) {\n    var newRhythm = $a0e9c665509477f7$export$85510b841f5c59b9(rhythm);\n    var measure = newRhythm.measures[measureIndex];\n    if (measure) {\n        var beat = measure.beats[beatIndex];\n        if (beat) {\n            var lastNote = beat.notes[beat.notes.length - 1];\n            beat.notes.push($a0e9c665509477f7$export$53eb9750d527b0ce(lastNote));\n        }\n    }\n    return newRhythm;\n}\nfunction $a0e9c665509477f7$export$8847734722b7329e(rhythm, measureIndex, beatIndex, noteIndex) {\n    var newRhythm = $a0e9c665509477f7$export$85510b841f5c59b9(rhythm);\n    var measure = newRhythm.measures[measureIndex];\n    if (measure) {\n        var beat = measure.beats[beatIndex];\n        if (beat) {\n            var note = beat.notes[noteIndex];\n            if (note) note.dynamics = (note.dynamics + 1) % (0, $515cd16560c8c62d$export$df409b90d2c1a310).Invalid;\n        }\n    }\n    return newRhythm;\n}\nfunction $a0e9c665509477f7$export$84ca89dac13ca70a(rhythm, measureIndex, beatIndex) {\n    var newRhythm = $a0e9c665509477f7$export$85510b841f5c59b9(rhythm);\n    var measure = newRhythm.measures[measureIndex];\n    if (measure) {\n        var beat = measure.beats[beatIndex];\n        if (beat) {\n            if (beat.notes.length === 1) measure.beats.splice(beatIndex, 1);\n            else beat.notes = beat.notes.slice(0, beat.notes.length - 1);\n        }\n    }\n    return newRhythm;\n}\nfunction $a0e9c665509477f7$export$1e3c6a5020ae960f(rhythm) {\n    var measuresCount = 0;\n    var beatsCount = 0;\n    var notesCount = 0;\n    var ticksCount = 0;\n    var ticksPerBeat = 0;\n    var tempos = [];\n    switch(rhythm.tempo.type){\n        case \"uniform\":\n            tempos.push($a0e9c665509477f7$export$4305c4a638586d94(rhythm.tempo));\n            break;\n        case \"varying\":\n            for(var speed = rhythm.tempo.begin; speed <= rhythm.tempo.end; speed += rhythm.tempo.step)tempos.push({\n                type: \"uniform\",\n                speed: speed\n            });\n            break;\n    }\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = rhythm.measures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var measure = _step.value;\n            measuresCount = measuresCount + measure.repeat;\n            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;\n            try {\n                for(var _iterator1 = measure.beats[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){\n                    var beat = _step1.value;\n                    beatsCount = beatsCount + measure.repeat;\n                    notesCount = notesCount + beat.notes.length * measure.repeat;\n                    ticksPerBeat = (0, $4c23d83373745e4f$export$f686d97e407ec4ef)(ticksPerBeat, beat.notes.length);\n                }\n            } catch (err) {\n                _didIteratorError1 = true;\n                _iteratorError1 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion1 && _iterator1[\"return\"] != null) {\n                        _iterator1[\"return\"]();\n                    }\n                } finally{\n                    if (_didIteratorError1) {\n                        throw _iteratorError1;\n                    }\n                }\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    ticksCount = beatsCount * ticksPerBeat;\n    return {\n        tempos: tempos,\n        measuresCount: measuresCount,\n        beatsCount: beatsCount,\n        notesCount: notesCount,\n        ticksCount: ticksCount,\n        ticksPerBeat: ticksPerBeat\n    };\n}\nfunction $a0e9c665509477f7$export$5200e0c7549d7bff(rhythm, ticksPerBeat, tickIndex) {\n    var measureIndex = 0;\n    var measureOffset = 0;\n    var beatIndex = 0;\n    var beatOffset = 0;\n    var noteIndex = 0;\n    var noteOffset = 0;\n    var ticksCount = 0;\n    for(var currMeasureIndex = 0; currMeasureIndex < rhythm.measures.length; currMeasureIndex++){\n        var currMeasure = rhythm.measures[currMeasureIndex];\n        for(var currMeasureOffset = 0; currMeasureOffset < currMeasure.repeat; currMeasureOffset++)for(var currBeatIndex = 0; currBeatIndex < currMeasure.beats.length; currBeatIndex++){\n            var currBeat = currMeasure.beats[currBeatIndex];\n            var maxTicksCount = ticksCount + ticksPerBeat;\n            if (maxTicksCount - 1 < tickIndex) {\n                ticksCount = maxTicksCount;\n                beatOffset = beatOffset + 1;\n                noteOffset = noteOffset + currBeat.notes.length;\n                continue;\n            }\n            measureIndex = currMeasureIndex;\n            measureOffset = currMeasureOffset;\n            beatIndex = currBeatIndex;\n            noteIndex = Math.floor(tickIndex % ticksPerBeat / (ticksPerBeat / currBeat.notes.length));\n            noteOffset = noteOffset + noteIndex;\n            return {\n                measureOffset: measureOffset,\n                measureIndex: measureIndex,\n                beatIndex: beatIndex,\n                beatOffset: beatOffset,\n                noteIndex: noteIndex,\n                noteOffset: noteOffset\n            };\n        }\n    }\n    return {\n        measureOffset: measureOffset,\n        measureIndex: measureIndex,\n        beatIndex: beatIndex,\n        beatOffset: beatOffset,\n        noteIndex: noteIndex,\n        noteOffset: noteOffset\n    };\n}\nfunction $a0e9c665509477f7$export$58aa5c5c19a2f2cb(rhythm, measureIndex, measureOffset, beatIndex, beatOffset) {\n    var measure = rhythm.measures[measureIndex];\n    if (beatIndex >= measure.beats.length - 1) {\n        var measureCount = 0;\n        for(var i = 0; i < measureIndex; i++)measureCount = measureCount + rhythm.measures[measureIndex].repeat;\n        if (measureCount + measure.repeat <= measureOffset + 1) {\n            if (measureIndex >= rhythm.measures.length - 1) return;\n            else {\n                measure = rhythm.measures[measureIndex + 1];\n                return {\n                    measureIndex: measureIndex + 1,\n                    measureOffset: measureOffset + 1,\n                    beatIndex: 0,\n                    beatOffset: beatOffset + 1\n                };\n            }\n        } else return {\n            measureIndex: measureIndex,\n            measureOffset: measureOffset,\n            beatIndex: beatIndex + 1,\n            beatOffset: beatOffset + 1\n        };\n    } else return {\n        measureIndex: measureIndex,\n        measureOffset: measureOffset,\n        beatIndex: beatIndex + 1,\n        beatOffset: beatOffset + 1\n    };\n}\n\n\n\nvar $89bcaaa777754897$export$158bbc173906b542 = 1000;\nvar $89bcaaa777754897$export$544c576050746347 = 60;\nvar $89bcaaa777754897$export$9245831f62081b68 = $89bcaaa777754897$export$544c576050746347 * $89bcaaa777754897$export$158bbc173906b542;\n\n\nvar $3c215dd1e12969fd$var$timerMap = new Map();\nvar $3c215dd1e12969fd$export$2cd96fc3b1b618d8;\n(function(TickType) {\n    TickType[TickType[\"First\"] = 0] = \"First\";\n    TickType[TickType[\"Middle\"] = 1] = \"Middle\";\n    TickType[TickType[\"Last\"] = 2] = \"Last\";\n})($3c215dd1e12969fd$export$2cd96fc3b1b618d8 || ($3c215dd1e12969fd$export$2cd96fc3b1b618d8 = {}));\nfunction $3c215dd1e12969fd$export$1c43efaafc52b831(task, callback) {\n    var id = task.id, rhythm = task.rhythm, preparatoryTime = task.preparatoryTime, beginTime = task.beginTime, tempo = task.tempo, ticksCount = task.ticksCount, ticksPerBeat = task.ticksPerBeat;\n    var tickIndex = -1;\n    var handleTick = function() {\n        tickIndex++;\n        var _locate = (0, $a0e9c665509477f7$export$5200e0c7549d7bff)(rhythm, ticksPerBeat, tickIndex), measureIndex = _locate.measureIndex, measureOffset = _locate.measureOffset, beatIndex = _locate.beatIndex, beatOffset = _locate.beatOffset, noteIndex = _locate.noteIndex, noteOffset = _locate.noteOffset;\n        callback({\n            type: \"tick\",\n            tick: {\n                measureOffset: measureOffset,\n                measureIndex: measureIndex,\n                beatIndex: beatIndex,\n                beatOffset: beatOffset,\n                noteIndex: noteIndex,\n                noteOffset: noteOffset,\n                tickIndex: tickIndex\n            }\n        }, task);\n        if (tickIndex >= ticksCount - 1) {\n            var timer = $3c215dd1e12969fd$var$timerMap.get(task.id);\n            if (timer === null || timer === void 0 ? void 0 : timer.tickIntervalId) {\n                self.clearInterval(timer === null || timer === void 0 ? void 0 : timer.tickIntervalId);\n                timer.tickIntervalId = null;\n            }\n        }\n    };\n    var tickInterval = (0, $89bcaaa777754897$export$9245831f62081b68) / (ticksPerBeat * tempo.speed);\n    var handleTickerBegin = function() {\n        var timer = $3c215dd1e12969fd$var$timerMap.get(task.id);\n        if (timer) timer.tickIntervalId = self.setInterval(handleTick, tickInterval);\n    };\n    var handleTickerPreparatory = function() {\n        callback({\n            type: \"preparatory\"\n        }, task);\n    };\n    var preparatoryTimeoutId = self.setTimeout(handleTickerPreparatory, preparatoryTime);\n    var beginTimeoutId = self.setTimeout(handleTickerBegin, beginTime - tickInterval);\n    var timer = {\n        beginTimeoutId: beginTimeoutId,\n        preparatoryTimeoutId: preparatoryTimeoutId,\n        tickIntervalId: null\n    };\n    $3c215dd1e12969fd$var$timerMap.set(id, timer);\n}\nfunction $3c215dd1e12969fd$export$d9d592371c2a2f98(task) {\n    var timer = $3c215dd1e12969fd$var$timerMap.get(task.id);\n    if (timer === null || timer === void 0 ? void 0 : timer.preparatoryTimeoutId) self.clearTimeout(timer.preparatoryTimeoutId);\n    if (timer === null || timer === void 0 ? void 0 : timer.beginTimeoutId) self.clearTimeout(timer.beginTimeoutId);\n    if (timer === null || timer === void 0 ? void 0 : timer.tickIntervalId) self.clearInterval(timer.tickIntervalId);\n}\n$b354d50e5cbd063c$export$9b7f6e342a8cbd38({\n    startTask: $3c215dd1e12969fd$export$1c43efaafc52b831,\n    stopTask: $3c215dd1e12969fd$export$d9d592371c2a2f98\n});\n\n})();\n//# sourceMappingURL=ticker.7b56a5df.js.map\n","import * as Comlink from 'comlink';\nimport { Rhythm, UniformTempo, locate } from '@musicpal/music';\nimport { MILLISECONDS_PER_MINUTE } from '@musicpal/music';\n\nexport interface TickerTask {\n  id: string;\n  rhythm: Rhythm;\n  tempo: UniformTempo;\n  preparatoryTime: number;\n  beginTime: number;\n  ticksPerBeat: number;\n  ticksCount: number;\n}\n\nexport interface TickerTimer {\n  preparatoryTimeoutId: number;\n  beginTimeoutId: number;\n  tickIntervalId: number | null;\n}\n\nconst timerMap: Map<TickerTask['id'], TickerTimer> = new Map();\n\nexport enum TickType {\n  First = 0,\n  Middle = 1,\n  Last = 2,\n}\n\nexport interface Tick {\n  measureIndex: number;\n  measureOffset: number;\n  beatIndex: number;\n  beatOffset: number;\n  noteIndex: number;\n  noteOffset: number;\n  tickIndex: number;\n}\n\nexport interface TickerPreparatoryEvent {\n  type: 'preparatory';\n}\n\nexport interface TickerTickEvent {\n  type: 'tick';\n  tick: Tick;\n}\n\nexport type TickerEvent = TickerPreparatoryEvent | TickerTickEvent;\n\nexport function startTask(\n  task: TickerTask,\n  callback: (event: TickerEvent, ticker: TickerTask) => void,\n) {\n  const {\n    id,\n    rhythm,\n    preparatoryTime,\n    beginTime,\n    tempo,\n    ticksCount,\n    ticksPerBeat,\n  } = task;\n  let tickIndex = -1;\n  const handleTick = () => {\n    tickIndex++;\n    const {\n      measureIndex,\n      measureOffset,\n      beatIndex,\n      beatOffset,\n      noteIndex,\n      noteOffset,\n    } = locate(rhythm, ticksPerBeat, tickIndex);\n    callback(\n      {\n        type: 'tick',\n        tick: {\n          measureOffset,\n          measureIndex,\n          beatIndex,\n          beatOffset,\n          noteIndex,\n          noteOffset,\n          tickIndex,\n        },\n      },\n      task,\n    );\n\n    if (tickIndex >= ticksCount - 1) {\n      const timer = timerMap.get(task.id);\n      if (timer?.tickIntervalId) {\n        self.clearInterval(timer?.tickIntervalId);\n        timer.tickIntervalId = null;\n      }\n    }\n  };\n\n  const tickInterval = MILLISECONDS_PER_MINUTE / (ticksPerBeat * tempo.speed);\n  const handleTickerBegin = () => {\n    const timer = timerMap.get(task.id);\n    if (timer) {\n      timer.tickIntervalId = self.setInterval(handleTick, tickInterval);\n    }\n  };\n\n  const handleTickerPreparatory = () => {\n    callback({ type: 'preparatory' }, task);\n  };\n\n  const preparatoryTimeoutId = self.setTimeout(\n    handleTickerPreparatory,\n    preparatoryTime,\n  );\n  const beginTimeoutId = self.setTimeout(\n    handleTickerBegin,\n    beginTime - tickInterval,\n  );\n  const timer: TickerTimer = {\n    beginTimeoutId,\n    preparatoryTimeoutId,\n    tickIntervalId: null,\n  };\n\n  timerMap.set(id, timer);\n}\n\nexport function stopTask(task: TickerTask) {\n  const timer = timerMap.get(task.id);\n\n  if (timer?.preparatoryTimeoutId) {\n    self.clearTimeout(timer.preparatoryTimeoutId);\n  }\n\n  if (timer?.beginTimeoutId) {\n    self.clearTimeout(timer.beginTimeoutId);\n  }\n\n  if (timer?.tickIntervalId) {\n    self.clearInterval(timer.tickIntervalId);\n  }\n}\n\nexport interface TickerWorker {\n  startTask: typeof startTask;\n  stopTask: typeof stopTask;\n}\n\nComlink.expose({\n  startTask,\n  stopTask,\n});\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport type { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\nexport const finalizer = Symbol(\"Comlink.finalizer\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nfunction isAllowedOrigin(\n  allowedOrigins: (string | RegExp)[],\n  origin: string\n): boolean {\n  for (const allowedOrigin of allowedOrigins) {\n    if (origin === allowedOrigin || allowedOrigin === \"*\") {\n      return true;\n    }\n    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function expose(\n  obj: any,\n  ep: Endpoint = globalThis as any,\n  allowedOrigins: (string | RegExp)[] = [\"*\"]\n) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n          if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n            obj[finalizer]();\n          }\n        }\n      })\n      .catch((error) => {\n        // Send Serialization Error To Caller\n        const [wireValue, transferables] = toWireValue({\n          value: new TypeError(\"Unserializable return value\"),\n          [throwMarker]: 0,\n        });\n        ep.postMessage({ ...wireValue, id }, transferables);\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction releaseEndpoint(ep: Endpoint) {\n  return requestResponseMessage(ep, {\n    type: MessageType.RELEASE,\n  }).then(() => {\n    closeEndPoint(ep);\n  });\n}\n\ninterface FinalizationRegistry<T> {\n  new (cb: (heldValue: T) => void): FinalizationRegistry<T>;\n  register(\n    weakItem: object,\n    heldValue: T,\n    unregisterToken?: object | undefined\n  ): void;\n  unregister(unregisterToken: object): void;\n}\ndeclare var FinalizationRegistry: FinalizationRegistry<Endpoint>;\n\nconst proxyCounter = new WeakMap<Endpoint, number>();\nconst proxyFinalizers =\n  \"FinalizationRegistry\" in globalThis &&\n  new FinalizationRegistry((ep: Endpoint) => {\n    const newCount = (proxyCounter.get(ep) || 0) - 1;\n    proxyCounter.set(ep, newCount);\n    if (newCount === 0) {\n      releaseEndpoint(ep);\n    }\n  });\n\nfunction registerProxy(proxy: object, ep: Endpoint) {\n  const newCount = (proxyCounter.get(ep) || 0) + 1;\n  proxyCounter.set(ep, newCount);\n  if (proxyFinalizers) {\n    proxyFinalizers.register(proxy, ep, proxy);\n  }\n}\n\nfunction unregisterProxy(proxy: object) {\n  if (proxyFinalizers) {\n    proxyFinalizers.unregister(proxy);\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          unregisterProxy(proxy);\n          releaseEndpoint(ep);\n          isProxyReleased = true;\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didn’t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  registerProxy(proxy, ep);\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T extends {}>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = globalThis,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n","import { _is_native_reflect_construct } from \"./_is_native_reflect_construct.js\";\nimport { _set_prototype_of } from \"./_set_prototype_of.js\";\nexport function _construct(Parent, args, Class) {\n    if (_is_native_reflect_construct()) _construct = Reflect.construct;\n    else {\n        _construct = function construct(Parent, args, Class) {\n            var a = [null];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n\n            if (Class) _set_prototype_of(instance, Class.prototype);\n\n            return instance;\n        };\n    }\n\n    return _construct.apply(null, arguments);\n}\nexport { _construct as _ };\n","export function _is_native_reflect_construct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nexport { _is_native_reflect_construct as _ };\n","export function _set_prototype_of(o, p) {\n    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {\n        o.__proto__ = p;\n\n        return o;\n    };\n\n    return _set_prototype_of(o, p);\n}\nexport { _set_prototype_of as _ };\n","export function _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n    } else obj[key] = value;\n\n    return obj;\n}\nexport { _define_property as _ };\n","import { _array_with_holes } from \"./_array_with_holes.js\";\nimport { _iterable_to_array_limit } from \"./_iterable_to_array_limit.js\";\nimport { _non_iterable_rest } from \"./_non_iterable_rest.js\";\nimport { _unsupported_iterable_to_array } from \"./_unsupported_iterable_to_array.js\";\n\nexport function _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nexport { _sliced_to_array as _ };\n","export function _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nexport { _array_with_holes as _ };\n","export function _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n    if (_i == null) return;\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n\n    try {\n        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally {\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally {\n            if (_d) throw _e;\n        }\n    }\n\n    return _arr;\n}\nexport { _iterable_to_array_limit as _ };\n","export function _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _non_iterable_rest as _ };\n","import { _array_like_to_array } from \"./_array_like_to_array.js\";\n\nexport function _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nexport { _unsupported_iterable_to_array as _ };\n","export function _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n}\nexport { _array_like_to_array as _ };\n","import { _array_without_holes } from \"./_array_without_holes.js\";\nimport { _iterable_to_array } from \"./_iterable_to_array.js\";\nimport { _non_iterable_spread } from \"./_non_iterable_spread.js\";\nimport { _unsupported_iterable_to_array } from \"./_unsupported_iterable_to_array.js\";\n\nexport function _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nexport { _to_consumable_array as _ };\n","import { _array_like_to_array } from \"./_array_like_to_array.js\";\n\nexport function _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nexport { _array_without_holes as _ };\n","export function _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) {\n        return Array.from(iter);\n    }\n}\nexport { _iterable_to_array as _ };\n","export function _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _non_iterable_spread as _ };\n","export * from './math';\nexport * from './theory';\nexport * from './rhythm';\nexport * from './common';\n\nexport const MILLISECONDS_PER_SECOND = 1000;\nexport const SECONDS_PER_MINUTE = 60;\nexport const MILLISECONDS_PER_MINUTE =\n  SECONDS_PER_MINUTE * MILLISECONDS_PER_SECOND;\n","export function gcd(num1: number, num2: number) {\n  if (num1 % num2 == 0) {\n    return num2;\n  } else {\n    return gcd(num2, num1 % num2);\n  }\n}\n\nexport function lcm(num1: number, num2: number) {\n  if (num1 === 0) {\n    return num2;\n  }\n\n  if (num2 === 0) {\n    return num1;\n  }\n\n  return (num1 * num2) / gcd(num1, num2);\n}\n","export interface UniformTempo {\n  type: 'uniform';\n  speed: number;\n}\n\nexport interface VaryingTempo {\n  type: 'varying';\n  begin: number;\n  step: number;\n  end: number;\n}\n\nexport type Tempo = UniformTempo | VaryingTempo;\n\nexport enum Dynamics {\n  None = 0,\n  Light,\n  Accent,\n  Invalid,\n}\n\nexport enum NoteName {\n  C,\n  CSharp,\n  D,\n  DSharp,\n  E,\n  F,\n  FSharp,\n  G,\n  GSharp,\n  A,\n  ASharp,\n  B,\n}\n\nexport interface Note {\n  name: NoteName;\n  octave: number;\n  dynamics: Dynamics;\n}\n\nexport interface Beat {\n  notes: Note[];\n}\nexport interface Measure {\n  repeat: number;\n  beats: Beat[];\n}\n\nexport interface Rhythm {\n  id: string;\n  name: string;\n  order: number;\n  preparatoryBeats: number;\n  tempo: Tempo;\n  createdTime: Date;\n  updatedTime: Date;\n  measures: Measure[];\n}\n","import { DEFAULT_MEASURES } from './common';\nimport { lcm } from './math';\nimport {\n  Tempo,\n  Note,\n  Beat,\n  Measure,\n  Rhythm,\n  Dynamics,\n  UniformTempo,\n} from './theory';\nimport * as R from 'ramda';\n\nexport function cloneTempo<T extends Tempo>(tempo: T): T {\n  return R.clone(tempo);\n}\n\nexport function cloneNote(note: Note): Note {\n  return R.clone(note);\n}\n\nexport function cloneBeat(beat: Beat): Beat {\n  return R.clone(beat);\n}\n\nexport function cloneMeasure(measure: Measure): Measure {\n  return R.clone(measure);\n}\n\nexport function cloneRhythm(rhythm: Rhythm): Rhythm {\n  return R.clone(rhythm);\n}\n\nexport function changePreparatory(rhythm: Rhythm, preparatory: number) {\n  const newRhythm = cloneRhythm(rhythm);\n  newRhythm.preparatoryBeats = preparatory;\n\n  return newRhythm;\n}\n\nexport function changeTempo(rhythm: Rhythm, tempo: Tempo) {\n  const newRhythm = cloneRhythm(rhythm);\n  newRhythm.tempo = cloneTempo(tempo);\n\n  return newRhythm;\n}\n\nexport function addMeasure(rhythm: Rhythm) {\n  const newRhythm = cloneRhythm(rhythm);\n  const lastMeasure = newRhythm.measures[rhythm.measures.length - 1];\n  if (lastMeasure) {\n    newRhythm.measures.push(cloneMeasure(lastMeasure));\n  } else {\n    newRhythm.measures = DEFAULT_MEASURES;\n  }\n\n  return newRhythm;\n}\n\nexport function removeMeasure(rhythm: Rhythm, measureIndex: number) {\n  const newRhythm = cloneRhythm(rhythm);\n  newRhythm.measures.splice(measureIndex, 1);\n\n  return newRhythm;\n}\n\nexport function changeRepeat(\n  rhythm: Rhythm,\n  measureIndex: number,\n  repeat: number,\n) {\n  const newRhythm = cloneRhythm(rhythm);\n  const measure = newRhythm.measures[measureIndex];\n  if (measure) {\n    measure.repeat = repeat;\n  }\n\n  return newRhythm;\n}\n\nexport function addBeat(rhythm: Rhythm, measureIndex: number) {\n  const newRhythm = cloneRhythm(rhythm);\n  const measure = newRhythm.measures[measureIndex];\n  if (measure) {\n    const beat = measure.beats[measure.beats.length - 1];\n    if (beat) {\n      measure.beats.push(cloneBeat(beat));\n    }\n  }\n\n  return newRhythm;\n}\n\nexport function removeBeat(rhythm: Rhythm, measureIndex: number) {\n  const newRhythm = cloneRhythm(rhythm);\n  const measure = newRhythm.measures[measureIndex];\n  if (measure) {\n    measure.beats = measure.beats.slice(0, measure.beats.length - 1);\n    if (measure.beats.length === 0) {\n      newRhythm.measures.splice(measureIndex, 1);\n    }\n  }\n\n  return newRhythm;\n}\n\nexport function addNote(\n  rhythm: Rhythm,\n  measureIndex: number,\n  beatIndex: number,\n) {\n  const newRhythm = cloneRhythm(rhythm);\n\n  const measure = newRhythm.measures[measureIndex];\n  if (measure) {\n    const beat = measure.beats[beatIndex];\n    if (beat) {\n      const lastNote = beat.notes[beat.notes.length - 1];\n      beat.notes.push(cloneNote(lastNote));\n    }\n  }\n\n  return newRhythm;\n}\n\nexport function changeNote(\n  rhythm: Rhythm,\n  measureIndex: number,\n  beatIndex: number,\n  noteIndex: number,\n) {\n  const newRhythm = cloneRhythm(rhythm);\n\n  const measure = newRhythm.measures[measureIndex];\n  if (measure) {\n    const beat = measure.beats[beatIndex];\n    if (beat) {\n      const note = beat.notes[noteIndex];\n      if (note) {\n        note.dynamics = (note.dynamics + 1) % Dynamics.Invalid;\n      }\n    }\n  }\n\n  return newRhythm;\n}\n\nexport function removeNote(\n  rhythm: Rhythm,\n  measureIndex: number,\n  beatIndex: number,\n) {\n  const newRhythm = cloneRhythm(rhythm);\n\n  const measure = newRhythm.measures[measureIndex];\n  if (measure) {\n    const beat = measure.beats[beatIndex];\n    if (beat) {\n      if (beat.notes.length === 1) {\n        measure.beats.splice(beatIndex, 1);\n      } else {\n        beat.notes = beat.notes.slice(0, beat.notes.length - 1);\n      }\n    }\n  }\n\n  return newRhythm;\n}\n\nexport function analyseRhythm(rhythm: Rhythm) {\n  let measuresCount = 0;\n  let beatsCount = 0;\n  let notesCount = 0;\n  let ticksCount = 0;\n  let ticksPerBeat = 0;\n  let tempos: UniformTempo[] = [];\n\n  switch (rhythm.tempo.type) {\n    case 'uniform':\n      tempos.push(cloneTempo(rhythm.tempo));\n      break;\n    case 'varying':\n      {\n        for (\n          let speed = rhythm.tempo.begin;\n          speed <= rhythm.tempo.end;\n          speed += rhythm.tempo.step\n        ) {\n          tempos.push({\n            type: 'uniform',\n            speed,\n          });\n        }\n      }\n      break;\n  }\n\n  for (const measure of rhythm.measures) {\n    measuresCount = measuresCount + measure.repeat;\n\n    for (const beat of measure.beats) {\n      beatsCount = beatsCount + measure.repeat;\n\n      notesCount = notesCount + beat.notes.length * measure.repeat;\n\n      ticksPerBeat = lcm(ticksPerBeat, beat.notes.length);\n    }\n  }\n  ticksCount = beatsCount * ticksPerBeat;\n\n  return {\n    tempos,\n    measuresCount,\n    beatsCount,\n    notesCount,\n    ticksCount,\n    ticksPerBeat,\n  };\n}\n\nexport function locate(\n  rhythm: Rhythm,\n  ticksPerBeat: number,\n  tickIndex: number,\n) {\n  let measureIndex = 0;\n  let measureOffset = 0;\n  let beatIndex = 0;\n  let beatOffset = 0;\n  let noteIndex = 0;\n  let noteOffset = 0;\n  let ticksCount = 0;\n\n  for (\n    let currMeasureIndex = 0;\n    currMeasureIndex < rhythm.measures.length;\n    currMeasureIndex++\n  ) {\n    const currMeasure = rhythm.measures[currMeasureIndex];\n\n    for (\n      let currMeasureOffset = 0;\n      currMeasureOffset < currMeasure.repeat;\n      currMeasureOffset++\n    ) {\n      for (\n        let currBeatIndex = 0;\n        currBeatIndex < currMeasure.beats.length;\n        currBeatIndex++\n      ) {\n        const currBeat = currMeasure.beats[currBeatIndex];\n        const maxTicksCount = ticksCount + ticksPerBeat;\n        if (maxTicksCount - 1 < tickIndex) {\n          ticksCount = maxTicksCount;\n          beatOffset = beatOffset + 1;\n          noteOffset = noteOffset + currBeat.notes.length;\n          continue;\n        }\n\n        measureIndex = currMeasureIndex;\n        measureOffset = currMeasureOffset;\n        beatIndex = currBeatIndex;\n        noteIndex = Math.floor(\n          (tickIndex % ticksPerBeat) / (ticksPerBeat / currBeat.notes.length),\n        );\n        noteOffset = noteOffset + noteIndex;\n\n        return {\n          measureOffset,\n          measureIndex,\n          beatIndex,\n          beatOffset,\n          noteIndex,\n          noteOffset,\n        };\n      }\n    }\n  }\n\n  return {\n    measureOffset,\n    measureIndex,\n    beatIndex,\n    beatOffset,\n    noteIndex,\n    noteOffset,\n  };\n}\n\nexport function locateNextBeat(\n  rhythm: Rhythm,\n  measureIndex: number,\n  measureOffset: number,\n  beatIndex: number,\n  beatOffset: number,\n) {\n  let measure = rhythm.measures[measureIndex];\n  if (beatIndex >= measure.beats.length - 1) {\n    let measureCount = 0;\n    for (let i = 0; i < measureIndex; i++) {\n      measureCount = measureCount + rhythm.measures[measureIndex].repeat;\n    }\n\n    if (measureCount + measure.repeat <= measureOffset + 1) {\n      if (measureIndex >= rhythm.measures.length - 1) {\n        return;\n      } else {\n        measure = rhythm.measures[measureIndex + 1];\n\n        return {\n          measureIndex: measureIndex + 1,\n          measureOffset: measureOffset + 1,\n          beatIndex: 0,\n          beatOffset: beatOffset + 1,\n        };\n      }\n    } else {\n      return {\n        measureIndex: measureIndex,\n        measureOffset: measureOffset,\n        beatIndex: beatIndex + 1,\n        beatOffset: beatOffset + 1,\n      };\n    }\n  } else {\n    return {\n      measureIndex: measureIndex,\n      measureOffset: measureOffset,\n      beatIndex: beatIndex + 1,\n      beatOffset: beatOffset + 1,\n    };\n  }\n}\n","import {\n  Dynamics,\n  Measure,\n  Note,\n  NoteName,\n  UniformTempo,\n  VaryingTempo,\n} from './theory';\n\nexport const UNIFORM_BPM_60: UniformTempo = {\n  type: 'uniform',\n  speed: 60,\n};\n\nexport const VARYING_BPM_60: VaryingTempo = {\n  type: 'varying',\n  begin: 60,\n  end: 60,\n  step: 10,\n};\n\nexport const DEFAULT_BEAT_ACCENT_NOTE: Note = {\n  name: NoteName.A,\n  octave: 4,\n  dynamics: Dynamics.Accent,\n};\n\nexport const DEFAULT_BEAT_LIGHT_NOTE: Note = {\n  name: NoteName.A,\n  octave: 4,\n  dynamics: Dynamics.Light,\n};\n\nexport const DEFAULT_MEASURES: Measure[] = [\n  {\n    repeat: 1,\n    beats: [\n      {\n        notes: [DEFAULT_BEAT_ACCENT_NOTE],\n      },\n      {\n        notes: [DEFAULT_BEAT_LIGHT_NOTE],\n      },\n      {\n        notes: [DEFAULT_BEAT_LIGHT_NOTE],\n      },\n      {\n        notes: [DEFAULT_BEAT_LIGHT_NOTE],\n      },\n      {\n        notes: [DEFAULT_BEAT_ACCENT_NOTE],\n      },\n      {\n        notes: [DEFAULT_BEAT_LIGHT_NOTE],\n      },\n      {\n        notes: [DEFAULT_BEAT_LIGHT_NOTE],\n      },\n      {\n        notes: [DEFAULT_BEAT_LIGHT_NOTE],\n      },\n    ],\n  },\n];\n\nexport const NOTE_A4: Note = {\n  name: NoteName.A,\n  octave: 4,\n  dynamics: Dynamics.None,\n};\n\nexport const CONCERT_PITCH = 440; // A4\n\nexport function stringifyNoteName(noteName: NoteName) {\n  switch (noteName) {\n    case NoteName.C:\n      return 'C';\n    case NoteName.CSharp:\n      return 'C#';\n    case NoteName.D:\n      return 'D';\n    case NoteName.DSharp:\n      return 'D#';\n    case NoteName.E:\n      return 'E';\n    case NoteName.F:\n      return 'F';\n    case NoteName.FSharp:\n      return 'F#';\n    case NoteName.G:\n      return 'G';\n    case NoteName.GSharp:\n      return 'G#';\n    case NoteName.A:\n      return 'A';\n    case NoteName.ASharp:\n      return 'A#';\n    case NoteName.B:\n      return 'B';\n  }\n}\n\nexport function stringifyNote(note: Note) {\n  return `${stringifyNoteName(note.name)}${note.octave}`;\n}\n\nexport function getInterval(noteA: Note, noteB: Note) {\n  return 12 * (noteA.octave - noteB.octave) + (noteA.name - noteB.name);\n}\n\nexport function getNoteFrequency(note: Note) {\n  const halfSteps = getInterval(note, NOTE_A4);\n\n  return Math.pow(2, halfSteps / 12) * CONCERT_PITCH;\n}\n\nexport function getNoteFromFrequency(frequency: number, dynamics: Dynamics) {\n  const halfSteps =\n    Math.round((Math.log(frequency / CONCERT_PITCH) * 12) / Math.log(2)) -\n    (NoteName.C - NoteName.A);\n\n  const octave = Math.floor(halfSteps / 12) + NOTE_A4.octave;\n  const name = (halfSteps - (octave - NOTE_A4.octave) * 12) % (NoteName.B + 1);\n\n  return {\n    name,\n    octave,\n    dynamics,\n  };\n}\n\n// Based on ACF2+ algorithm\nexport function detectPitch(audioBuffer: Float32Array, sampleRate: number) {\n  const audioSize = audioBuffer.length;\n  let rms = 0;\n\n  for (let i = 0; i < audioSize; i++) {\n    let val = audioBuffer[i];\n    rms += val * val;\n  }\n  rms = Math.sqrt(rms / audioSize);\n  if (rms < 0.01) {\n    return -1;\n  }\n\n  let startIndex = 0;\n  let endIndex = audioSize - 1;\n  let threshold = 0.2;\n  for (let i = 0; i < audioSize / 2; i++) {\n    if (Math.abs(audioBuffer[i]) < threshold) {\n      startIndex = i;\n      break;\n    }\n  }\n\n  for (let i = 1; i < audioSize / 2; i++) {\n    if (Math.abs(audioBuffer[audioSize - i]) < threshold) {\n      endIndex = audioSize - i;\n      break;\n    }\n  }\n\n  const audioSlice = audioBuffer.slice(startIndex, endIndex);\n  const sliceSize = audioSlice.length;\n\n  let c = new Array(sliceSize).fill(0);\n  for (let i = 0; i < sliceSize; i++) {\n    for (let j = 0; j < sliceSize - i; j++) {\n      c[i] = c[i] + audioSlice[j] * audioSlice[j + i];\n    }\n  }\n\n  let d = 0;\n  while (c[d] > c[d + 1]) {\n    d++;\n  }\n  let maxval = -1;\n  let maxpos = -1;\n  for (let i = d; i < sliceSize; i++) {\n    if (c[i] > maxval) {\n      maxval = c[i];\n      maxpos = i;\n    }\n  }\n  let T0 = maxpos;\n\n  let x1 = c[T0 - 1];\n  let x2 = c[T0];\n  let x3 = c[T0 + 1];\n  let a = (x1 + x3 - 2 * x2) / 2;\n  let b = (x3 - x1) / 2;\n  if (a) {\n    T0 = T0 - b / (2 * a);\n  }\n\n  return sampleRate / T0;\n}\n","import _clone from \"./internal/_clone.js\";\nimport _curry1 from \"./internal/_curry1.js\";\n/**\n * Creates a deep copy of the source that can be used in place of the source\n * object without retaining any references to it.\n * The source object may contain (nested) `Array`s and `Object`s,\n * `Number`s, `String`s, `Boolean`s and `Date`s.\n * `Function`s are assigned by reference rather than copied.\n *\n * Dispatches to a `clone` method if present.\n *\n * Note that if the source object has multiple nodes that share a reference,\n * the returned object will have the same structure, but the references will\n * be pointed to the location within the cloned value.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @sig {*} -> {*}\n * @param {*} value The object or array to clone\n * @return {*} A deeply cloned copy of `val`\n * @example\n *\n *      const objects = [{}, {}, {}];\n *      const objectsClone = R.clone(objects);\n *      objects === objectsClone; //=> false\n *      objects[0] === objectsClone[0]; //=> false\n */\n\nvar clone =\n/*#__PURE__*/\n_curry1(function clone(value) {\n  return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, true);\n});\n\nexport default clone;","import _cloneRegExp from \"./_cloneRegExp.js\";\nimport type from \"../type.js\";\n/**\n * Copies an object.\n *\n * @private\n * @param {*} value The value to be copied\n * @param {Boolean} deep Whether or not to perform deep cloning.\n * @return {*} The copied value.\n */\n\nexport default function _clone(value, deep, map) {\n  map || (map = new _ObjectMap()); // this avoids the slower switch with a quick if decision removing some milliseconds in each run.\n\n  if (_isPrimitive(value)) {\n    return value;\n  }\n\n  var copy = function copy(copiedValue) {\n    // Check for circular and same references on the object graph and return its corresponding clone.\n    var cachedCopy = map.get(value);\n\n    if (cachedCopy) {\n      return cachedCopy;\n    }\n\n    map.set(value, copiedValue);\n\n    for (var key in value) {\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        copiedValue[key] = deep ? _clone(value[key], true, map) : value[key];\n      }\n    }\n\n    return copiedValue;\n  };\n\n  switch (type(value)) {\n    case 'Object':\n      return copy(Object.create(Object.getPrototypeOf(value)));\n\n    case 'Array':\n      return copy([]);\n\n    case 'Date':\n      return new Date(value.valueOf());\n\n    case 'RegExp':\n      return _cloneRegExp(value);\n\n    case 'Int8Array':\n    case 'Uint8Array':\n    case 'Uint8ClampedArray':\n    case 'Int16Array':\n    case 'Uint16Array':\n    case 'Int32Array':\n    case 'Uint32Array':\n    case 'Float32Array':\n    case 'Float64Array':\n    case 'BigInt64Array':\n    case 'BigUint64Array':\n      return value.slice();\n\n    default:\n      return value;\n  }\n}\n\nfunction _isPrimitive(param) {\n  var type = typeof param;\n  return param == null || type != 'object' && type != 'function';\n}\n\nvar _ObjectMap =\n/*#__PURE__*/\nfunction () {\n  function _ObjectMap() {\n    this.map = {};\n    this.length = 0;\n  }\n\n  _ObjectMap.prototype.set = function (key, value) {\n    const hashedKey = this.hash(key);\n    let bucket = this.map[hashedKey];\n\n    if (!bucket) {\n      this.map[hashedKey] = bucket = [];\n    }\n\n    bucket.push([key, value]);\n    this.length += 1;\n  };\n\n  _ObjectMap.prototype.hash = function (key) {\n    let hashedKey = [];\n\n    for (var value in key) {\n      hashedKey.push(Object.prototype.toString.call(key[value]));\n    }\n\n    return hashedKey.join();\n  };\n\n  _ObjectMap.prototype.get = function (key) {\n    /**\n     * depending on the number of objects to be cloned is faster to just iterate over the items in the map just because the hash function is so costly,\n     * on my tests this number is 180, anything above that using the hash function is faster.\n     */\n    if (this.length <= 180) {\n      for (const p in this.map) {\n        const bucket = this.map[p];\n\n        for (let i = 0; i < bucket.length; i += 1) {\n          const element = bucket[i];\n\n          if (element[0] === key) {\n            return element[1];\n          }\n        }\n      }\n\n      return;\n    }\n\n    const hashedKey = this.hash(key);\n    const bucket = this.map[hashedKey];\n\n    if (!bucket) {\n      return;\n    }\n\n    for (let i = 0; i < bucket.length; i += 1) {\n      const element = bucket[i];\n\n      if (element[0] === key) {\n        return element[1];\n      }\n    }\n  };\n\n  return _ObjectMap;\n}();","export function _type_of(obj) {\n    \"@swc/helpers - typeof\";\n\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nexport { _type_of as _ };\n","export default function _cloneRegExp(pattern) {\n  return new RegExp(pattern.source, pattern.flags ? pattern.flags : (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : '') + (pattern.dotAll ? 's' : ''));\n}","import _curry1 from \"./internal/_curry1.js\";\n/**\n * Gives a single-word string description of the (native) type of a value,\n * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not\n * attempt to distinguish user Object types any further, reporting them all as\n * 'Object'.\n *\n * @func\n * @memberOf R\n * @since v0.8.0\n * @category Type\n * @sig * -> String\n * @param {*} val The value to test\n * @return {String}\n * @example\n *\n *      R.type({}); //=> \"Object\"\n *      R.type(1); //=> \"Number\"\n *      R.type(false); //=> \"Boolean\"\n *      R.type('s'); //=> \"String\"\n *      R.type(null); //=> \"Null\"\n *      R.type([]); //=> \"Array\"\n *      R.type(/[A-z]/); //=> \"RegExp\"\n *      R.type(() => {}); //=> \"Function\"\n *      R.type(async () => {}); //=> \"AsyncFunction\"\n *      R.type(undefined); //=> \"Undefined\"\n */\n\nvar type =\n/*#__PURE__*/\n_curry1(function type(val) {\n  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);\n});\n\nexport default type;","import _isPlaceholder from \"./_isPlaceholder.js\";\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\nexport default function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}","export default function _isPlaceholder(a) {\n  return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n}"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","Dynamics","NoteName","TickType","$515cd16560c8c62d$export$df409b90d2c1a310","$515cd16560c8c62d$export$2050b8129d8cdad6","$3c215dd1e12969fd$export$2cd96fc3b1b618d8","$3c215dd1e12969fd$exports","$ade657966c9f3425$export$c2c98ac76e997b63","o","p","setPrototypeOf","__proto__","$9e42a30d1410267f$export$2d841144c5f8c4ab","Parent","args","Class","Reflect","construct","sham","Proxy","Boolean","prototype","valueOf","call","a","push","apply","instance","Function","bind","arguments","$e70e36fe5deea41b$export$1e71eb4bef00f6b0","obj","key","value","writable","$e1771364af16df86$export$79e617b1955a2616","arr","len","length","i","arr2","Array","$4d2bd7d199d3d5af$export$a5be06335b3a083c","minLen","toString","slice","constructor","name","from","test","$35211f8b9a4957d2$export$fdf2a89c76341bbf","isArray","_s","_e","_i","Symbol","iterator","_arr","_n","_d","next","done","err","TypeError","$129d079e0dffb367$export$1b5e630bc3aea29f","iter","$3c215dd1e12969fd$export$1c43efaafc52b831","$3c215dd1e12969fd$export$d9d592371c2a2f98","$b354d50e5cbd063c$export$be5234c0b764b6e0","$b354d50e5cbd063c$export$39fb953702b7fcd7","$b354d50e5cbd063c$export$89981d4b8d9f48aa","$b354d50e5cbd063c$export$ddc31dfe7c269837","$b354d50e5cbd063c$var$throwMarker","$b354d50e5cbd063c$var$isObject","val","$b354d50e5cbd063c$export$ab8f1c00731ee83e","Map","canHandle","serialize","_ref","MessageChannel","port1","port2","$b354d50e5cbd063c$export$9b7f6e342a8cbd38","deserialize","port","start","$b354d50e5cbd063c$var$createProxy","ep","newCount","path","target","isProxyReleased","proxy","_target","prop","$b354d50e5cbd063c$var$throwIfProxyReleased","$b354d50e5cbd063c$var$proxyFinalizers","unregister","$b354d50e5cbd063c$var$releaseEndpoint","then","r","$b354d50e5cbd063c$var$requestResponseMessage","type","map","$b354d50e5cbd063c$var$fromWireValue","concat","rawValue","_toWireValue","$b354d50e5cbd063c$var$toWireValue","transferables","_thisArg","rawArgumentList","last","_processArguments","$b354d50e5cbd063c$var$processArguments","argumentList","$b354d50e5cbd063c$var$proxyCounter","register","param","Error","isError","message","stack","serialized","assign","globalThis","allowedOrigins","addEventListener","callback","ev","data","$b354d50e5cbd063c$var$isAllowedOrigin","origin","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","allowedOrigin","RegExp","console","warn","returnValue","_Object_assign","id","parent","reduce","transfers","$b354d50e5cbd063c$var$transferCache","Promise","resolve","wireValue","postMessage","removeEventListener","$b354d50e5cbd063c$var$closeEndPoint","error","endpoint","close","isReleased","WeakMap","FinalizationRegistry","processed","_step_value","handler","_handler_serialize","serializedValue","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","l","A","Accent","Light","None","$3c215dd1e12969fd$var$timerMap","task","rhythm","preparatoryTime","beginTime","tempo","ticksCount","ticksPerBeat","tickIndex","handleTick","_locate","measureIndex","measureOffset","beatIndex","beatOffset","noteIndex","noteOffset","currMeasureIndex","measures","currMeasure","currMeasureOffset","repeat","currBeatIndex","beats","currBeat","maxTicksCount","notes","tick","timer","tickIntervalId","self","clearInterval","tickInterval","$89bcaaa777754897$export$544c576050746347","speed","preparatoryTimeoutId","setTimeout","beginTimeoutId","setInterval","clearTimeout","startTask","stopTask"],"version":3,"file":"ticker.7b56a5df.js.map"}